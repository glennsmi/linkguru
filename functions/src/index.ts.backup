import { onRequest, onCall } from 'firebase-functions/v2/https';
import { setGlobalOptions } from 'firebase-functions/v2';
import * as admin from 'firebase-admin';
import cors from 'cors';
import * as QRCode from 'qrcode';
import {
  createSuccessResponse,
  createErrorResponse,
  User,
  userSchema,
  paginationSchema,
  COLLECTIONS,
  FirestoreUser,
  // Link Guru imports
  Link,
  Tenant,
  LINK_COLLECTIONS,
  createLinkRequestSchema,
  getLinksRequestSchema,
  type CreateLinkResponseType,
  type FirestoreLink,
  type FirestoreTenant,
  DeviceType
} from '../../shared/dist';

// Set global options for all functions
setGlobalOptions({
  region: 'us-central1',
  maxInstances: 10,
});

// Initialize Firebase Admin
admin.initializeApp();
const db = admin.firestore();

// CORS configuration
const corsHandler = cors({ origin: true });

// Helper function to convert Firestore timestamp to Date
const convertTimestamps = (data: any, id: string): User => {
  return {
    id,
    email: data.email,
    displayName: data.displayName,
    createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt),
    updatedAt: data.updatedAt?.toDate ? data.updatedAt.toDate() : new Date(data.updatedAt),
  };
};

// ============================================================================
// LINK GURU HELPER FUNCTIONS
// ============================================================================

// Generate a unique short ID
const generateShortId = (length: number = 6): string => {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
};

// Canonicalize UTM parameters into URL
const canonicalizeUrlWithUtm = (baseUrl: string, utm?: any): string => {
  if (!utm) return baseUrl;

  const url = new URL(baseUrl);
  const params = url.searchParams;

  // Standard UTM parameters (lowercased)
  const utmKeys = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content'];

  utmKeys.forEach(key => {
    const value = utm[key.replace('utm_', '')];
    if (value) {
      // Lowercase the key, preserve value casing
      params.set(key, value);
    }
  });

  // Add any custom UTM parameters
  Object.entries(utm).forEach(([key, value]) => {
    if (value && !utmKeys.includes(`utm_${key}`)) {
      params.set(`utm_${key}`, value as string);
    }
  });

  return url.toString();
};

// Convert Firestore Link document to Link type
const convertFirestoreLink = (data: any, id: string): Link => {
  return {
    id,
    tenantId: data.tenantId,
    shortId: data.shortId,
    longUrl: data.longUrl,
    originalUrl: data.originalUrl,
    utm: data.utm || null,
    metadata: {
      title: data.metadata?.title,
      tags: data.metadata?.tags || [],
      createdBy: data.metadata?.createdBy,
      createdAt: data.metadata?.createdAt?.toDate ? data.metadata.createdAt.toDate() : new Date(data.metadata.createdAt),
      lastModified: data.metadata?.lastModified?.toDate ? data.metadata.lastModified.toDate() : undefined,
      isActive: data.metadata?.isActive ?? true,
      expiresAt: data.metadata?.expiresAt?.toDate ? data.metadata.expiresAt.toDate() : undefined,
    },
    qrConfig: data.qrConfig || null,
    stats: {
      totalClicks: data.stats?.totalClicks || 0,
      lastClickAt: data.stats?.lastClickAt?.toDate ? data.stats.lastClickAt.toDate() : undefined,
    },
  };
};

// Convert Firestore Tenant document to Tenant type
const convertFirestoreTenant = (data: any, id: string): Tenant => {
  return {
    id,
    name: data.name,
    plan: data.plan || 'free',
    limits: {
      activeLinks: data.limits?.activeLinks || 5,
      monthlyClicks: data.limits?.monthlyClicks || 1000,
    },
    createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt),
    createdBy: data.createdBy,
    settings: {
      defaultUtm: data.settings?.defaultUtm,
      brandColors: data.settings?.brandColors,
    },
  };
};

// Check if user is a member of tenant
const isTenantMember = async (tenantId: string, userId: string): Promise<boolean> => {
  try {
    const memberDoc = await db.collection(LINK_COLLECTIONS.TENANTS)
      .doc(tenantId)
      .collection(LINK_COLLECTIONS.TENANT_MEMBERS)
      .doc(userId)
      .get();
    return memberDoc.exists;
  } catch (error) {
    return false;
  }
};

// Validate URL accessibility (basic check)
const validateUrl = async (url: string): Promise<boolean> => {
  try {
    const response = await fetch(url, {
      method: 'HEAD',
      signal: AbortSignal.timeout(5000), // 5 second timeout
    });
    return response.ok;
  } catch (error) {
    // For development, accept URLs even if we can't validate them
    console.warn('URL validation failed:', error);
    return true;
  }
};

// HTTP Function Example
export const helloWorld = onRequest((request, response) => {
  corsHandler(request, response, () => {
    try {
      const message = 'Hello from Firebase Functions v2 in US Central 1!';
      const apiResponse = createSuccessResponse({ message }, 'Function executed successfully');
      
      response.json(apiResponse);
    } catch (error) {
      const errorResponse = createErrorResponse(
        'Internal server error',
        error instanceof Error ? error.message : 'Unknown error'
      );
      response.status(500).json(errorResponse);
    }
  });
});

// Callable Function Example with Firestore integration
export const getUsers = onCall(async (request) => {
  try {
    // Validate pagination parameters
    const paginationResult = paginationSchema.safeParse(request.data);
    
    if (!paginationResult.success) {
      return createErrorResponse('Invalid pagination parameters', paginationResult.error.message);
    }

    const { page, limit } = paginationResult.data;

    // Get users from Firestore
    const usersRef = db.collection(COLLECTIONS.USERS);
    const snapshot = await usersRef
      .orderBy('createdAt', 'desc')
      .limit(limit)
      .offset((page - 1) * limit)
      .get();

    const users: User[] = [];
    snapshot.forEach(doc => {
      const userData = doc.data() as FirestoreUser;
      users.push(convertTimestamps(userData, doc.id));
    });

    // Get total count for pagination
    const totalSnapshot = await usersRef.count().get();
    const total = totalSnapshot.data().count;

    const response = createSuccessResponse(users, 'Users retrieved successfully');
    
    return {
      ...response,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  } catch (error) {
    return createErrorResponse(
      'Failed to retrieve users',
      error instanceof Error ? error.message : 'Unknown error'
    );
  }
});

// Callable Function to create a user in Firestore
export const createUser = onCall(async (request) => {
  try {
    // Check if user is authenticated
    if (!request.auth) {
      return createErrorResponse('Authentication required', 'User must be logged in');
    }

    // Validate the user data using Zod schema
    const userData = userSchema.omit({ id: true, createdAt: true, updatedAt: true }).parse(request.data);
    
    const now = admin.firestore.FieldValue.serverTimestamp();
    const newUserData = {
      email: userData.email,
      displayName: userData.displayName,
      createdAt: now,
      updatedAt: now,
    };

    // Save to Firestore
    const docRef = await db.collection(COLLECTIONS.USERS).add(newUserData);
    const doc = await docRef.get();
    const createdUser = convertTimestamps(doc.data() as FirestoreUser, doc.id);

    return createSuccessResponse(createdUser, 'User created successfully');
  } catch (error) {
    return createErrorResponse(
      'Failed to create user',
      error instanceof Error ? error.message : 'Invalid user data'
    );
  }
});

// Callable Function to get current user profile
export const getCurrentUser = onCall(async (request) => {
  try {
    if (!request.auth) {
      return createErrorResponse('Authentication required', 'User must be logged in');
    }

    const userDoc = await db.collection(COLLECTIONS.USERS).doc(request.auth.uid).get();
    
    if (!userDoc.exists) {
      return createErrorResponse('User not found', 'User profile does not exist');
    }

    const userData = userDoc.data() as FirestoreUser;
    const user = convertTimestamps(userData, userDoc.id);

    return createSuccessResponse(user, 'User profile retrieved successfully');
  } catch (error) {
    return createErrorResponse(
      'Failed to retrieve user profile',
      error instanceof Error ? error.message : 'Unknown error'
    );
  }
});

// Callable Function to update user profile
export const updateUser = onCall(async (request) => {
  try {
    if (!request.auth) {
      return createErrorResponse('Authentication required', 'User must be logged in');
    }

    const updateData = userSchema.omit({ id: true, createdAt: true, updatedAt: true, email: true }).parse(request.data);

    const updatePayload = {
      ...updateData,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    };

    await db.collection(COLLECTIONS.USERS).doc(request.auth.uid).update(updatePayload);

    // Get updated user
    const userDoc = await db.collection(COLLECTIONS.USERS).doc(request.auth.uid).get();
    const userData = userDoc.data() as FirestoreUser;
    const user = convertTimestamps(userData, userDoc.id);

    return createSuccessResponse(user, 'User profile updated successfully');
  } catch (error) {
    return createErrorResponse(
      'Failed to update user profile',
      error instanceof Error ? error.message : 'Invalid user data'
    );
  }
});

// ============================================================================
// LINK GURU FUNCTIONS
// ============================================================================

// Create Short Link Function - TEMPORARILY DISABLED
export const createShortLinkDisabled = onCall(async (request) => {
  try {
    if (!request.auth) {
      return createErrorResponse('Authentication required', 'User must be logged in');
    }

    // Validate request data
    const requestData = createLinkRequestSchema.parse(request.data);
    const { tenantId, originalUrl, customSlug, utm, qrConfig, tags, expiresAt } = requestData;

    // Check tenant membership
    const isMember = await isTenantMember(tenantId, request.auth.uid);
    if (!isMember) {
      return createErrorResponse('Access denied', 'You are not a member of this tenant');
    }

    // Validate URL
    const isValidUrl = await validateUrl(originalUrl);
    if (!isValidUrl) {
      return createErrorResponse('Invalid URL', 'The provided URL is not accessible');
    }

    // Check tenant link limits
    const tenantDoc = await db.collection(LINK_COLLECTIONS.TENANTS).doc(tenantId).get();
    if (!tenantDoc.exists) {
      return createErrorResponse('Tenant not found', 'Invalid tenant ID');
    }

    const tenant = convertFirestoreTenant(tenantDoc.data() as FirestoreTenant, tenantId);
    const activeLinksQuery = await db.collection(LINK_COLLECTIONS.TENANTS)
      .doc(tenantId)
      .collection(LINK_COLLECTIONS.LINKS)
      .where('metadata.isActive', '==', true)
      .count()
      .get();

    if (activeLinksQuery.data().count >= tenant.limits.activeLinks) {
      return createErrorResponse('Limit exceeded', `Free tier allows up to ${tenant.limits.activeLinks} active links`);
    }

    // Generate or validate short ID
    let shortId = customSlug || generateShortId();

    // Check if shortId is available (global uniqueness)
    const existingLink = await db.collectionGroup(LINK_COLLECTIONS.LINKS)
      .where('shortId', '==', shortId)
      .limit(1)
      .get();

    if (!existingLink.empty) {
      if (customSlug) {
        return createErrorResponse('Slug taken', 'This custom slug is already in use');
      }
      // Regenerate for auto-generated slugs
      shortId = generateShortId();
    }

    // Canonicalize URL with UTM parameters
    const longUrl = canonicalizeUrlWithUtm(originalUrl, utm);

    // Create link document
    const now = admin.firestore.FieldValue.serverTimestamp();
    const linkData = {
      tenantId,
      shortId,
      longUrl,
      originalUrl,
      utm: utm || null,
      metadata: {
        createdBy: request.auth.uid,
        createdAt: now,
        lastModified: now,
        isActive: true,
        tags: tags || [],
        expiresAt: expiresAt ? admin.firestore.Timestamp.fromDate(expiresAt) : null,
      },
      qrConfig: qrConfig || null,
      stats: {
        totalClicks: 0,
        lastClickAt: null,
      },
    };

    const linkRef = await db.collection(LINK_COLLECTIONS.TENANTS)
      .doc(tenantId)
      .collection(LINK_COLLECTIONS.LINKS)
      .add(linkData);

    const response: CreateLinkResponseType = {
      linkId: linkRef.id,
      shortId,
      shortUrl: `https://s.linkguru.app/r/${shortId}`,
      qrUrls: {
        png: `https://s.linkguru.app/qr/${shortId}.png`,
        svg: `https://s.linkguru.app/qr/${shortId}.svg`,
      },
    };

    return createSuccessResponse(response, 'Short link created successfully');

  } catch (error) {
    console.error('Create short link error:', error);
    return createErrorResponse(
      'Failed to create short link',
      error instanceof Error ? error.message : 'Invalid request data'
    );
  }
});

// Redirect Function (HTTP endpoint) - TEMPORARILY DISABLED
export const redirectDisabled = onRequest(
  { cors: false }, // No CORS for redirects
  async (request, response) => {
    try {
      const { shortId } = request.params as { shortId: string };

      if (!shortId) {
        response.status(400).send('Short ID is required');
        return;
      }

      // Find the link by shortId
      const linkQuery = await db.collectionGroup(LINK_COLLECTIONS.LINKS)
        .where('shortId', '==', shortId)
        .limit(1)
        .get();

      if (linkQuery.empty) {
        response.status(404).send('Link not found');
        return;
      }

      const linkDoc = linkQuery.docs[0];
      const linkData = linkDoc.data() as FirestoreLink;
      const link = convertFirestoreLink(linkData, linkDoc.id);

      // Check if link is active
      if (!link.metadata.isActive) {
        response.status(410).send('Link is inactive');
        return;
      }

      // Check if link has expired
      if (link.metadata.expiresAt && link.metadata.expiresAt < new Date()) {
        response.status(410).send('Link has expired');
        return;
      }

      // Log click event (fire and forget for performance)
      const userAgent = request.headers['user-agent'] || '';
      const referrer = request.headers.referer || '';

      // Basic device detection
      let device: DeviceType = 'unknown';
      if (userAgent.includes('Mobile')) {
        device = 'mobile';
      } else if (userAgent.includes('Tablet')) {
        device = 'tablet';
      } else if (!userAgent.includes('bot')) {
        device = 'desktop';
      } else {
        device = 'bot';
      }

      const clickData = {
        linkId: link.id,
        tenantId: link.tenantId,
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
        bucket: Math.floor(Math.random() * 10), // For sharding
        referrer: referrer || null,
        userAgent: userAgent || null,
        device,
        browser: null, // Would need additional parsing
        os: null, // Would need additional parsing
        location: null, // Would need IP geolocation service
        ipHash: null, // Would need IP hashing for privacy
      };

      // Fire and forget - don't wait for click logging
      db.collection(LINK_COLLECTIONS.TENANTS)
        .doc(link.tenantId)
        .collection(LINK_COLLECTIONS.LINKS)
        .doc(link.id)
        .collection(LINK_COLLECTIONS.CLICKS)
        .add(clickData)
        .catch(err => console.error('Failed to log click:', err));

      // Update click count (also fire and forget)
      db.collection(LINK_COLLECTIONS.TENANTS)
        .doc(link.tenantId)
        .collection(LINK_COLLECTIONS.LINKS)
        .doc(link.id)
        .update({
          'stats.totalClicks': admin.firestore.FieldValue.increment(1),
          'stats.lastClickAt': admin.firestore.FieldValue.serverTimestamp(),
        })
        .catch(err => console.error('Failed to update click count:', err));

      // Perform redirect
      response.redirect(302, link.longUrl);

    } catch (error) {
      console.error('Redirect error:', error);
      response.status(500).send('Internal server error');
    }
  }
);

// Create Tenant Function - TEMPORARILY DISABLED
export const createTenantDisabled = onCall(async (request) => {
  try {
    if (!request.auth) {
      return createErrorResponse('Authentication required', 'User must be logged in');
    }

    const { name } = request.data;
    if (!name || typeof name !== 'string' || name.trim().length === 0) {
      return createErrorResponse('Invalid input', 'Tenant name is required');
    }

    const now = admin.firestore.FieldValue.serverTimestamp();
    
    // Create tenant document
    const tenantData = {
      name: name.trim(),
      plan: 'free',
      limits: {
        activeLinks: 5,
        monthlyClicks: 1000,
      },
      createdAt: now,
      createdBy: request.auth.uid,
      settings: {
        defaultUtm: null,
        brandColors: null,
      },
    };

    const tenantRef = await db.collection(LINK_COLLECTIONS.TENANTS).add(tenantData);

    // Add user as owner of the tenant
    const memberData = {
      role: 'owner',
      joinedAt: now,
      invitedBy: request.auth.uid,
    };

    await db.collection(LINK_COLLECTIONS.TENANTS)
      .doc(tenantRef.id)
      .collection(LINK_COLLECTIONS.TENANT_MEMBERS)
      .doc(request.auth.uid)
      .set(memberData);

    const tenant = convertFirestoreTenant(tenantData, tenantRef.id);
    return createSuccessResponse(tenant, 'Tenant created successfully');

  } catch (error) {
    console.error('Create tenant error:', error);
    return createErrorResponse(
      'Failed to create tenant',
      error instanceof Error ? error.message : 'Unknown error'
    );
  }
});

// Get User Tenants Function - TEMPORARILY DISABLED
export const getUserTenantsDisabled = onCall(async (request) => {
  try {
    if (!request.auth) {
      return createErrorResponse('Authentication required', 'User must be logged in');
    }

    // Get all tenants where user is a member
    const membershipsQuery = await db.collectionGroup(LINK_COLLECTIONS.TENANT_MEMBERS)
      .where('__name__', '==', request.auth.uid)
      .get();

    const tenantIds = membershipsQuery.docs.map(doc => {
      const path = doc.ref.path;
      return path.split('/')[1]; // Extract tenantId from path
    });

    if (tenantIds.length === 0) {
      return createSuccessResponse([], 'No tenants found');
    }

    // Get tenant documents
    const tenants: Tenant[] = [];
    for (const tenantId of tenantIds) {
      const tenantDoc = await db.collection(LINK_COLLECTIONS.TENANTS).doc(tenantId).get();
      if (tenantDoc.exists) {
        const tenantData = tenantDoc.data() as FirestoreTenant;
        tenants.push(convertFirestoreTenant(tenantData, tenantId));
      }
    }

    return createSuccessResponse(tenants, 'Tenants retrieved successfully');

  } catch (error) {
    console.error('Get user tenants error:', error);
    return createErrorResponse(
      'Failed to retrieve tenants',
      error instanceof Error ? error.message : 'Unknown error'
    );
  }
});

// Get Links Function (for tenant management) - TEMPORARILY DISABLED
export const getLinksDisabled = onCall(async (request) => {
  try {
    if (!request.auth) {
      return createErrorResponse('Authentication required', 'User must be logged in');
    }

    const requestData = getLinksRequestSchema.parse(request.data);
    const { tenantId, limit = 20, offset, status, sortBy = 'createdAt', sortOrder = 'desc' } = requestData;

    // Check tenant membership
    const isMember = await isTenantMember(tenantId, request.auth.uid);
    if (!isMember) {
      return createErrorResponse('Access denied', 'You are not a member of this tenant');
    }

    let query: admin.firestore.Query = db.collection(LINK_COLLECTIONS.TENANTS)
      .doc(tenantId)
      .collection(LINK_COLLECTIONS.LINKS);

    // Apply filters
    if (status) {
      if (status === 'active') {
        query = query.where('metadata.isActive', '==', true);
      } else if (status === 'inactive') {
        query = query.where('metadata.isActive', '==', false);
      } else if (status === 'expired') {
        // Note: Firestore doesn't support complex date queries easily
        // This would need to be handled client-side or with a different approach
      }
    }

    // Apply sorting
    const sortField = sortBy === 'createdAt' ? 'metadata.createdAt' :
                     sortBy === 'clicks' ? 'stats.totalClicks' : 'metadata.createdAt';
    query = query.orderBy(sortField, sortOrder);

    // Apply pagination
    if (offset) {
      const offsetDoc = await db.collection(LINK_COLLECTIONS.TENANTS)
        .doc(tenantId)
        .collection(LINK_COLLECTIONS.LINKS)
        .doc(offset)
        .get();

      if (offsetDoc.exists) {
        query = query.startAfter(offsetDoc);
      }
    }

    query = query.limit(limit);

    const snapshot = await query.get();
    const links: Link[] = [];

    snapshot.forEach(doc => {
      const linkData = doc.data() as FirestoreLink;
      links.push(convertFirestoreLink(linkData, doc.id));
    });

    // Note: Total count calculation removed for simplicity
    // In production, you might want to maintain a counter or use pagination tokens

    return createSuccessResponse(links, 'Links retrieved successfully');

  } catch (error) {
    console.error('Get links error:', error);
    return createErrorResponse(
      'Failed to retrieve links',
      error instanceof Error ? error.message : 'Invalid request'
    );
  }
});

// QR Code Generation Function (HTTP endpoint) - TEMPORARILY DISABLED
export const generateQRDisabled = onRequest(
  { cors: false }, // No CORS for QR images
  async (request, response) => {
    try {
      const { shortId, format = 'png' } = request.params as { shortId: string; format?: string };
      const { size = 200, ecLevel = 'M', foregroundColor = '#000000', backgroundColor = '#ffffff' } = request.query;

      if (!shortId) {
        response.status(400).send('Short ID is required');
        return;
      }

      // Find the link by shortId
      const linkQuery = await db.collectionGroup(LINK_COLLECTIONS.LINKS)
        .where('shortId', '==', shortId)
        .limit(1)
        .get();

      if (linkQuery.empty) {
        response.status(404).send('Link not found');
        return;
      }

      const linkDoc = linkQuery.docs[0];
      const linkData = linkDoc.data() as FirestoreLink;
      const link = convertFirestoreLink(linkData, linkDoc.id);

      // Check if link is active
      if (!link.metadata.isActive) {
        response.status(410).send('Link is inactive');
        return;
      }

      // Check if link has expired
      if (link.metadata.expiresAt && link.metadata.expiresAt < new Date()) {
        response.status(410).send('Link has expired');
        return;
      }

      // Generate QR code
      const shortUrl = `https://s.linkguru.app/r/${shortId}`;
      
      if (format === 'svg') {
        const qrOptions = {
          type: 'svg' as const,
          width: parseInt(size as string) || 200,
          errorCorrectionLevel: ecLevel as 'L' | 'M' | 'Q' | 'H',
          color: {
            dark: foregroundColor as string,
            light: backgroundColor as string,
          },
          margin: 2,
        };

        const qrData = await QRCode.toString(shortUrl, qrOptions);
        response.setHeader('Content-Type', 'image/svg+xml');
        response.setHeader('Cache-Control', 'public, max-age=3600'); // 1 hour cache
        response.send(qrData);
      } else {
        const qrOptions = {
          type: 'image/png' as const,
          width: parseInt(size as string) || 200,
          errorCorrectionLevel: ecLevel as 'L' | 'M' | 'Q' | 'H',
          color: {
            dark: foregroundColor as string,
            light: backgroundColor as string,
          },
          margin: 2,
        };

        const qrData = await QRCode.toDataURL(shortUrl, qrOptions);
        const base64Data = qrData.split(',')[1];
        const buffer = Buffer.from(base64Data, 'base64');
        
        response.setHeader('Content-Type', 'image/png');
        response.setHeader('Cache-Control', 'public, max-age=3600'); // 1 hour cache
        response.setHeader('Content-Length', buffer.length.toString());
        
        response.send(buffer);
      }

    } catch (error) {
      console.error('QR generation error:', error);
      response.status(500).send('Internal server error');
    }
  }
);

